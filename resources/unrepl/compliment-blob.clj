(clojure.core/let [prefix__1837__auto__ (clojure.core/name (clojure.core/gensym)) rdr__1838__auto__ (clojure.core/-> "(ns compliment.utils\n  \"Functions and utilities for source implementations.\"\n  (:import java.io.File java.nio.file.Files\n           [java.util.jar JarFile JarEntry]))\n\n(def ^:dynamic *extra-metadata*\n  \"Signals to downstream sources which additional information about completion\n  candidates they should attach . Should be a set of keywords.\"\n  nil)\n\n(defn fuzzy-matches?\n  \"Tests if symbol matches the prefix when symbol is split into parts on\n  separator.\"\n  [prefix, ^String symbol, separator]\n  (when (or (.startsWith symbol prefix) (= (first prefix) (first symbol)))\n    (loop [pre (rest prefix), sym (rest symbol), skipping false]\n      (cond (empty? pre) true\n            (empty? sym) false\n            skipping (if (= (first sym) separator)\n                       (recur (if (= (first pre) separator)\n                                (rest pre) pre)\n                              (rest sym) false)\n                       (recur pre (rest sym) true))\n            (= (first pre) (first sym)) (recur (rest pre) (rest sym) false)\n            :else (recur pre (rest sym) (not= (first sym) separator))))))\n\n(defn fuzzy-matches-no-skip?\n  \"Tests if symbol matches the prefix where separator? checks whether character\n  is a separator. Unlike `fuzzy-matches?` requires separator characters to be\n  present in prefix.\"\n  [prefix, ^String symbol, separator?]\n  (when (or (.startsWith symbol prefix) (= (first prefix) (first symbol)))\n    (loop [pre prefix, sym symbol, skipping false]\n      (cond (empty? pre) true\n            (empty? sym) false\n            skipping (if (separator? (first sym))\n                       (recur pre sym false)\n                       (recur pre (rest sym) true))\n            (= (first pre) (first sym)) (recur (rest pre) (rest sym) false)\n            :else (recur pre (rest sym) true)))))\n\n(defn resolve-class\n  \"Tries to resolve a classname from the given symbol, or returns nil\n  if classname can't be resolved.\"\n  [ns sym]\n  (when-let [val (try (ns-resolve ns sym)\n                      (catch ClassNotFoundException ex nil))]\n    (when (class? val) val)))\n\n(defn resolve-namespace\n  \"Tries to resolve a namespace from the given symbol, either from a\n  fully qualified name or an alias in the given namespace.\"\n  [sym ns]\n  (or (find-ns sym) ((ns-aliases ns) sym)))\n\n(defmacro ^{:doc \"Defines a memoized function.\"\n            :forms '([name doc-string? [params*] body])}\n  defmemoized [name & fdecl]\n  (let [[doc & fdecl] (if (string? (first fdecl))\n                        [(first fdecl) (rest fdecl)]\n                        [\"\" fdecl])]\n    `(def ~name ~doc (memoize (fn ~@fdecl)))))\n\n(def primitive-cache (atom {}))\n\n(defmacro cache-last-result\n  \"If cache for `name` is absent, or `key` doesn't match the key in the cache,\n  calculate `v` and return it. Else return value from cache.\"\n  {:style/indent 2}\n  [name key value]\n  (let [ksym ()]\n    `(let [name# ~name\n           key# ~key\n           [cached-key# cached-value#] (@primitive-cache name#)]\n       (if (and (contains? @primitive-cache name#) (= cached-key# key#))\n         cached-value#\n         (let [value# ~value]\n           (swap! primitive-cache assoc name# [key# value#])\n           value#)))))\n\n(defn flush-caches\n  \"Removes all cached values, forcing functions that depend on\n  `cache-last-result` to recalculate.\"\n  []\n  (reset! primitive-cache {}))\n\n;; Classpath inspection\n\n(def android-vm?\n  \"Signifies if the application is running on Android.\"\n  (.contains ^String (System/getProperty \"java.vendor\") \"Android\"))\n\n(defn- classpath\n  \"Returns a sequence of File objects of the elements on the classpath.\"\n  []\n  (if android-vm?\n    ()\n    (mapcat #(.split (or (System/getProperty %) \"\") File/pathSeparator)\n            [\"sun.boot.class.path\" \"java.ext.dirs\" \"java.class.path\"\n             ;; This is where Boot keeps references to dependencies.\n             \"fake.class.path\"])))\n\n(defn- symlink?\n  \"Checks if the given file is a symlink.\"\n  [^File f]\n  (Files/isSymbolicLink (.toPath f)))\n\n(defn- file-seq-nonr\n  \"A tree seq on java.io.Files, doesn't resolve symlinked directories to avoid\n  infinite sequence resulting from recursive symlinked directories.\"\n  [dir]\n  (tree-seq\n   (fn [^File f] (and (.isDirectory f) (not (symlink? f))))\n   (fn [^File d] (seq (.listFiles d)))\n   dir))\n\n(defn- list-files\n  \"Given a path (either a jar file, directory with classes or directory with\n  paths) returns all files under that path.\"\n  [^String path, scan-jars?]\n  (cond (.endsWith path \"/*\")\n        (for [^File jar (.listFiles (File. path))\n              :when (.endsWith ^String (.getName jar) \".jar\")\n              file (list-files (.getPath jar) scan-jars?)]\n          file)\n\n        (.endsWith path \".jar\")\n        (if scan-jars?\n          (try (for [^JarEntry entry (enumeration-seq (.entries (JarFile. path)))\n                     :when (not (.isDirectory entry))]\n                 (.getName entry))\n               (catch Exception e))\n          ())\n\n        (= path \"\") ()\n\n        :else\n        (for [^File file (file-seq-nonr (File. path))\n              :when (not (.isDirectory file))]\n          (.replace ^String (.getPath file) path \"\"))))\n\n(defn- all-files-on-classpath\n  \"Given a list of files on the classpath, returns the list of all files,\n  including those located inside jar files.\"\n  [classpath]\n  (cache-last-result ::all-files-on-classpath classpath\n    (mapcat #(list-files % true) classpath)))\n\n(defn classes-on-classpath\n  \"Returns a map of all classes that can be located on the classpath. Key\n  represent the root package of the class, and value is a list of all classes\n  for that package.\"\n  []\n  (let [classpath (classpath)]\n    (cache-last-result ::classes-on-classpath classpath\n      (->> (for [^String file (all-files-on-classpath classpath)\n                 :when (and (.endsWith file \".class\") (not (.contains file \"__\"))\n                            (not (.contains file \"$\")))]\n             (.. (if (.startsWith file File/separator)\n                   (.substring file 1) file)\n                 (replace \".class\" \"\") (replace File/separator \".\")))\n           (group-by #(subs % 0 (max (.indexOf ^String % \".\") 0)))))))\n\n(defn namespaces-on-classpath\n  \"Returns the list of all Clojure namespaces obtained by classpath scanning.\"\n  []\n  (let [classpath (classpath)]\n    (cache-last-result ::namespaces-on-classpath classpath\n      (set (for [^String file (all-files-on-classpath classpath)\n                 :when (and (.endsWith file \".clj\")\n                            (not (.startsWith file \"META-INF\")))\n                 :let [[_ ^String nsname] (re-matches #\"[^\\w]?(.+)\\.clj\" file)]\n                 :when nsname]\n             (.. nsname (replace File/separator \".\") (replace \"_\" \"-\")))))))\n\n(defn project-resources\n  \"Returns a list of all non-code files in the current project.\"\n  []\n  (let [classpath (classpath)]\n    (cache-last-result ::project-resources classpath\n      (for [path classpath\n            ^String file (list-files path false)\n            :when (not (or (empty? file) (.endsWith file \".clj\")\n                           (.endsWith file \".jar\") (.endsWith file \".class\")))]\n        (if (.startsWith file File/separator)\n          (.substring file 1) file)))))\n(ns compliment.sources\n  \"Tools for defining sources for the completion.\")\n\n(def ^{:doc \"Stores defined sources.\"\n       :private true}\n  sources (atom nil))\n\n(defn all-sources\n  \"Returns the list of all completion sources, or the selected once specified by\n  `source-kws`.\"\n  ([] @sources)\n  ([source-kws]\n   (select-keys @sources source-kws)))\n\n(defn defsource\n  \"Defines a source with the given name and argument map. Map must\n  contain two keys - `:candidates` and `:doc`.\n\n  Value of `:candidates`should be a function of prefix, namespace and\n  context.\n\n  Value of `:doc` latter should be a function of symbol name and\n  namespace.\"\n  [name & {:as kw-args}]\n  {:pre [(every? kw-args [:candidates :doc])]}\n  (swap! sources assoc name (assoc kw-args :enabled true)))\n(ns compliment.sources.class-members\n  \"Completion for both static and non-static class members.\"\n  (:require [compliment.sources :refer [defsource]]\n            [compliment.utils :refer [fuzzy-matches-no-skip? resolve-class]]\n            [clojure.string :refer [join]])\n  (:import [java.lang.reflect Method Field Member Modifier]))\n\n(defn static?\n  \"Tests if class member is static.\"\n  [^Member member]\n  (Modifier/isStatic (.getModifiers member)))\n\n;; ## Regular (non-static) members\n\n(def ^{:doc \"Stores cache of all non-static members for every\n  namespace.\"}\n  members-cache (atom {}))\n\n(defn populate-members-cache\n  \"Populates members cache for a given namespace. `classes-cnt` is a\n  number that indicates the current number of imported classes in this\n  namespace.\"\n  [ns classes-cnt]\n  (loop [cache (transient {})\n\n         [^Member c & r]\n         (for [^Class class (vals (ns-map ns))\n               :when (class? class)\n               ^Member member (concat (.getMethods class) (.getFields class))\n               :when (not (static? member))]\n           (let [dc (.getDeclaringClass member)]\n             (if (= dc class)\n               member\n               (if (instance? Method member)\n                 (.getMethod dc (.getName member)\n                             (.getParameterTypes ^Method member))\n                 (.getField dc (.getName member))))))]\n    (if c\n      (let [full-name (.getName c)]\n        (if (cache full-name)\n          (recur (assoc! cache full-name (conj (cache (.getName c)) c)) r)\n          (recur (assoc! cache full-name [c]) r)))\n      (swap! members-cache assoc ns {:classes-cnt classes-cnt\n                                     :methods (persistent! cache)}))))\n\n(defn update-cache\n  \"Updates members cache for a given namespace if necessary.\"\n  [ns]\n  (let [imported-cls-cnt (count (filter class? (vals (ns-map *ns*))))]\n    (when (or (nil? (@members-cache ns))\n              (not= (get-in @members-cache [ns :classes-cnt])\n                    imported-cls-cnt))\n      (populate-members-cache ns imported-cls-cnt))))\n\n(defn get-all-members\n  \"Returns all non-static members for a given namespace.\"\n  [ns]\n  (update-cache ns)\n  (get-in @members-cache [ns :methods]))\n\n(defn class-member-symbol?\n  \"Tests if a symbol name looks like a non-static class member.\"\n  [^String x]\n  (.startsWith x \".\"))\n\n(defn camel-case-matches?\n  \"Tests if prefix matches the member name following camel case rules.\n  Thus, prefix `getDeF` matches member `getDeclaredFields`.\"\n  [prefix member-name]\n  (fuzzy-matches-no-skip? prefix member-name #(Character/isUpperCase ^char %)))\n\n(defn try-get-object-class\n  \"Tries to get the type of the object from the context, which the\n  member will be applied to. Object should be a Var.\"\n  [ns context]\n  (when (= (:idx (first context)) 0)\n    (let [sym (second (:form (first context)))]\n      (when (and (symbol? sym)\n                 (= (type (ns-resolve ns sym)) clojure.lang.Var))\n        (type (deref (ns-resolve ns sym)))))))\n\n(defn members-candidates\n  \"Returns a list of Java non-static fields and methods candidates.\"\n  [prefix ns context]\n  (when (class-member-symbol? prefix)\n    (let [prefix (subs prefix 1)\n          inparts? (re-find #\"[A-Z]\" prefix)\n          klass (try-get-object-class ns context)]\n      (for [[member-name members] (get-all-members ns)\n            :when (if inparts?\n                    (camel-case-matches? prefix member-name)\n                    (.startsWith ^String member-name prefix))\n            :when\n            (or (not klass)\n                (some #(= klass (.getDeclaringClass ^Member %)) members))]\n        {:candidate (str \".\" member-name)\n         :type (if (instance? Method (first members))\n                 :method :field)}))))\n\n;; ### Member documentation\n\n(defn type-to-pretty-string\n  \"Takes a type (either a class or a primitive) and returns it's\n  human-readable name.\"\n  [^Class t]\n  (if (or (.isLocalClass t)\n          (.isMemberClass t))\n    (.getName t)\n    (.getSimpleName t)))\n\n(defn doc-method-parameters\n  \"Takes a list of method parameters and stringifies it.\"\n  [parameters]\n  (->> parameters\n       (map type-to-pretty-string)\n       (interpose \" \")\n       join\n       (format \"(%s)\")))\n\n(defn create-members-doc\n  \"Takes a list of members (presumably with the same name) and turns\n  them into a docstring.\"\n  [members]\n  (->> members\n       (group-by (fn [^Member m] (.getDeclaringClass m)))\n       (map (fn [[^Class class, members]]\n              (let [^Member f-mem (first members)]\n                (str (.getName class) \".\" (.getName f-mem)\n                     (if (instance? Field f-mem)\n                       (str \" = \" (try (.get ^Field f-mem nil)\n                                       (catch Exception e \"?\"))\n                            \" (\" (type-to-pretty-string (.getType ^Field f-mem)) \")\\n\"\n                            (Modifier/toString (.getModifiers f-mem)))\n                       (join\n                        (map (fn [^Method member]\n                               (when (instance? Method member)\n                                 (str \"\\n  \" (doc-method-parameters (.getParameterTypes member))\n                                      \" -> \" (type-to-pretty-string (.getReturnType ^Method member))\n                                      \" (\" (Modifier/toString (.getModifiers member)) \")\")))\n                             (distinct members))))\n                     \"\\n\"))))\n       (interpose \"\\n\")\n       join))\n\n(defn members-doc\n  \"Documentation function for non-static members.\"\n  [member-str ns]\n  (when (class-member-symbol? member-str)\n    (update-cache ns)\n    (when-let [member (get-in @members-cache [ns :methods (subs member-str 1)])]\n      (create-members-doc member))))\n\n(defn classname-doc [^Class class]\n  (let [members (group-by static? (concat (.getMethods class)\n                                          (.getFields class)))\n        [static non-static] (for [flag [true false]]\n                              (->> (for [^Member m (members flag)]\n                                     (.getName m))\n                                   distinct\n                                   (interpose \", \")\n                                   join))]\n    (str (.getName class) \"\\n\\n\"\n         \" Non-static members:\\n  \" non-static \"\\n\\n\"\n         \" Static members:\\n  \" static \"\\n\")))\n\n(defsource ::members\n  :candidates #'members-candidates\n  :doc #'members-doc\n  :tag-fn (fn [m {:keys [ns]}]\n            (assoc m :type (if (->> (get-in @members-cache [ns :methods\n                                                            (subs (:candidate m) 1)])\n                                    first\n                                    (instance? Method))\n                             :method :field))))\n\n;; ## Static members\n\n(defn static-member-symbol?\n  \"Tests if prefix looks like a static member symbol.\"\n  [x]\n  (re-matches #\"[^\\/\\:\\.][^\\:]*\\/.*\" x))\n\n(def ^{:doc \"Stores cache of all static members for every class.\"}\n  static-members-cache (atom {}))\n\n(defn populate-static-members-cache\n  \"Populates static members cache for a given class.\"\n  [^Class class]\n  (loop [cache {}, [^Member c & r] (concat (.getMethods class)\n                                           (.getFields class))]\n    (if c\n      (if (static? c)\n        (let [full-name (.getName c)]\n          (if (cache (.getName c))\n            (recur (update-in cache [full-name] conj c) r)\n            (recur (assoc cache full-name [c]) r)))\n        (recur cache r))\n      (swap! static-members-cache assoc class cache))))\n\n(defn update-static-cache\n  \"Updates static members cache for a given class if necessary.\"\n  [class]\n  (when-not (@static-members-cache class)\n    (populate-static-members-cache class)))\n\n(defn static-members\n  \"Returns all static members for a given class.\"\n  [^Class class]\n  (update-static-cache class)\n  (@static-members-cache class))\n\n(defn static-members-candidates\n  \"Returns a list of static member candidates.\"\n  [^String prefix, ns context]\n  (when (static-member-symbol? prefix)\n    (let [[cl-name member-prefix] (.split prefix \"/\")\n          cl (resolve-class ns (symbol cl-name))\n          member-prefix (or member-prefix \"\")]\n      (when cl\n        (let [inparts? (re-find #\"[A-Z]\" member-prefix)]\n          (for [[^String member-name members] (static-members cl)\n                :when  (if inparts?\n                         (camel-case-matches? member-prefix member-name)\n                         (.startsWith member-name member-prefix))]\n            {:candidate (str cl-name \"/\" member-name)\n             :type (if (instance? Method (first members))\n                     :static-method :static-field)}))))))\n\n(defn resolve-static-member\n  \"Given a string representation of a static member returns Member object.\"\n  [^String member-str ns]\n  (let [[cl-name member-name] (.split member-str \"/\")\n        cl (resolve-class ns (symbol cl-name))]\n    (when cl\n      (update-static-cache cl)\n      (get-in @static-members-cache [cl member-name]))))\n\n(defn static-member-doc\n  \"Given a member name and class returns its docstring.\"\n  [member-str ns]\n  (when (static-member-symbol? member-str)\n    (let [member (resolve-static-member member-str ns)]\n      (when member\n        (create-members-doc member)))))\n\n(defsource ::static-members\n  :candidates #'static-members-candidates\n  :doc #'static-member-doc)\n(ns compliment.context\n  \"Utilities for parsing and storing the current completion context.\"\n  (:require [clojure.walk :refer [walk]]))\n\n(defn- restore-map-literals [context]\n  (clojure.walk/postwalk (fn [el]\n                           (if (and (sequential? el)\n                                    (= (first el) 'compliment-hashmap))\n                             (apply hash-map\n                                    (if (even? (count el))\n                                      (concat (rest el) [nil])\n                                      (rest el)))\n                             el)) context))\n\n(defn- safe-read-context-string [^String context]\n  (try (-> context\n           (.replace \"{\" \"(compliment-hashmap \")\n           (.replace \"}\" \")\")\n           read-string\n           restore-map-literals)\n       (catch Exception ex nil)))\n\n(def ^{:doc \"Stores the last completion context.\"\n       :private true}\n  previous-context (atom nil))\n\n(def ^{:doc \"Special symbol which substitutes prefix in the context,\n  so the former can be found unambiguously.\"}\n  prefix-placeholder '__prefix__)\n\n(defn parse-context\n  \"Takes a context which is a Lisp form and returns a transformed context.\n\n  The result is a list of maps, each map represents a level of the\n  context from inside to outside. Map has `:idx` and `:form` values,\n  and `:map-role` if the level is a map. `:idx` defines the position\n  of prefix (or the form containing prefix) on the current\n  level (number for lists and vectors, key or value for maps).\n\n  Example: `(dotimes [i 10] ({:foo {:baz __prefix__}, :bar 42} :quux))`\n\n  Transformed it looks like:\n\n  `({:idx :baz, :map-role :value, :form {:baz __prefix__}}\n    {:idx :foo, :map-role :key, :form {:foo {:baz __prefix__}, :bar 42}}\n    {:idx 0, :form ({:foo {:baz __prefix__}, :bar 42} :quux)}\n    {:idx 2, :form (dotimes [i 10] ({:foo {:baz __prefix__}, :bar 42} :quux))})`.\"\n  [context]\n  (let [parse (fn parse [ctx]\n                (cond\n                 (sequential? ctx)\n                 (when-let [res (first (keep-indexed (fn [idx el]\n                                                       (when-let [p (parse el)]\n                                                         [idx p]))\n                                                     ctx))]\n                   (cons {:idx (first res) :form ctx} (second res)))\n\n                 (map? ctx)\n                 (when-let [res (first (keep (fn [[k v]]\n                                               (if-let [p (parse v)]\n                                                 [k :value p]\n                                                 (when-let [p (parse k)]\n                                                   [v :key p])))\n                                             ctx))]\n                   (cons {:idx (first res) :map-role (second res) :form ctx}\n                         (nth res 2)))\n\n                 (string? ctx)\n                 (let [idx (.indexOf ^String ctx (name prefix-placeholder))]\n                   (when (>= idx 0)\n                     [{:idx idx :form ctx}]))\n\n                 (= ctx prefix-placeholder) ()))\n        parsed (parse context)]\n    (when parsed\n      (reverse parsed))))\n\n(defn cache-context\n  \"Parses the context, or returns one from cache if it was unchanged.\"\n  [context-string]\n  (let [context (safe-read-context-string context-string)]\n    (when-not (= context :same)\n      (reset! previous-context (parse-context context))))\n  @previous-context)\n(ns compliment.sources.namespaces-and-classes\n  \"Completion for namespace and class names.\"\n  (:require [compliment.sources :refer [defsource]]\n            [compliment.utils :refer [fuzzy-matches?] :as utils]\n            [compliment.sources.class-members :refer [classname-doc]])\n  (:import java.io.File))\n\n(defn nscl-symbol?\n  \"Tests if prefix looks like a namespace or classname.\"\n  [x]\n  (re-matches #\"[^\\/\\:\\.][^\\/\\:]+\" x))\n\n(defn nscl-matches?\n  \"Tests if prefix partially matches a var name with periods as\n  separators.\"\n  [prefix namespace]\n  (fuzzy-matches? prefix namespace \\.))\n\n;;; Obtaining the list of classes\n\n(defn imported-classes\n  \"Returns names of all classes imported into a given namespace.\"\n  [ns]\n  (for [[_ ^Class val] (ns-map ns) :when (class? val)]\n    (.getName val)))\n\n(defn all-classes-short-names\n  \"Returns a map where short classnames are matched with vectors with\n  package-qualified classnames.\"\n  []\n  (let [all-classes (utils/classes-on-classpath)]\n    (utils/cache-last-result ::all-classes-short-names all-classes\n      (group-by #(-> (re-matches #\"([^\\.]+\\.)*([^\\.]+)\" %)\n                     (nth 2))\n                (reduce into [] (vals all-classes))))))\n\n(defn- analyze-import-context\n  \"Checks if the completion is called from ns import declaration. If so, and the\n  prefix is inside import vector, return that package name, otherwise return\n  `:root`. If not inside :import, return nil.\"\n  [ctx]\n  (let [ns-decl (:form (last ctx))\n        import-list (:form (last (butlast ctx)))\n        prefix-form (:form (first ctx))]\n    (when (and (sequential? ns-decl)\n               (= (first ns-decl) 'ns)\n               (sequential? import-list)\n               (= (first import-list) :import))\n      (if (= prefix-form import-list)\n        :root\n        (str (first prefix-form))))))\n\n(defn- get-all-full-names\n  \"Returns a list of package-qualified classnames given a short classname.\"\n  [prefix]\n  (reduce-kv (fn [l, ^String short-name, full-names]\n               (if (.startsWith short-name prefix)\n                 (concat l (map (fn [c] {:candidate c, :type :class})\n                                full-names))\n                 l))\n             ()\n             (all-classes-short-names)))\n\n(defn- get-classes-by-package-name\n  \"Returns simple classnames that match the `prefix` and belong to `pkg-name`.\"\n  [prefix pkg-name]\n  (reduce-kv (fn [l, ^String short-name, full-names]\n               (if (and (.startsWith short-name prefix)\n                        (some #(.startsWith ^String % pkg-name) full-names))\n                 (conj l {:candidate short-name, :type :class})\n                 l))\n             ()\n             (all-classes-short-names)))\n\n(defn candidates\n  \"Returns a list of namespace and classname completions.\"\n  [^String prefix, ns context]\n  (when (nscl-symbol? prefix)\n    (let [has-dot (> (.indexOf prefix \".\") -1)\n          import-ctx (analyze-import-context context)]\n      ((comp distinct concat)\n       (for [ns-str (concat (map (comp name ns-name) (all-ns))\n                            (map name (keys (ns-aliases ns))))\n             :when (nscl-matches? prefix ns-str)]\n         {:candidate ns-str, :type :namespace})\n       (for [class-str (imported-classes ns)\n             :when (nscl-matches? prefix class-str)]\n         {:candidate class-str, :type :class})\n       (cond (= import-ctx :root) (get-all-full-names prefix)\n             import-ctx (get-classes-by-package-name prefix import-ctx))\n       ;; Fuzziness is too slow for all classes, so just startsWith.\n       ;; Also have to do clever tricks to keep the performance high.\n       (if has-dot\n         (concat (for [[root-pkg classes] (utils/classes-on-classpath)\n                       :when (.startsWith prefix root-pkg)\n                       ^String cl-str classes\n                       :when (.startsWith cl-str prefix)]\n                   {:candidate cl-str, :type :class})\n                 (for [ns-str (utils/namespaces-on-classpath)\n                       :when (nscl-matches? prefix ns-str)]\n                   {:candidate ns-str, :type :namespace}))\n         (concat (for [[^String root-pkg _] (utils/classes-on-classpath)\n                       :when (.startsWith root-pkg prefix)]\n                   {:candidate (str root-pkg \".\"), :type :class})\n                 (for [^String ns-str (utils/namespaces-on-classpath)\n                       :when (.startsWith ns-str prefix)]\n                   {:candidate ns-str, :type :namespace})))))))\n\n(defn doc [ns-or-class-str curr-ns]\n  (when (nscl-symbol? ns-or-class-str)\n    (if-let [ns (find-ns (symbol ns-or-class-str))]\n      (str ns \"\\n\" (:doc (meta ns)) \"\\n\")\n      (when-let [class (try (ns-resolve curr-ns (symbol ns-or-class-str))\n                            (catch Exception ex nil))]\n        (when (= (type class) Class)\n          (classname-doc class))))))\n\n(defsource ::namespaces-and-classes\n  :candidates #'candidates\n  :doc #'doc)\n(ns compliment.sources.keywords\n  \"Completion for keywords interned globally across the application\"\n  (:require [compliment.sources :refer [defsource]]\n            [compliment.utils :refer [defmemoized resolve-namespace]])\n  (:import java.lang.reflect.Field))\n\n(defmemoized ^:private keywords-table\n  []\n  (let [^Field field (.getDeclaredField clojure.lang.Keyword \"table\")]\n    (.setAccessible field true)\n    (.get field nil)))\n\n(defn- tagged-candidate [c]\n  {:candidate c, :type :keyword})\n\n(defn qualified-candidates\n  \"Returns a list of namespace-qualified double-colon keywords (like ::foo)\n  resolved for the given namespace.\"\n  [prefix ns]\n  (let [prefix (subs prefix 2)\n        ns-name (str ns)]\n    (for [[kw _] (keywords-table)\n          :when (= (namespace kw) ns-name)\n          :when (.startsWith (name kw) prefix)]\n      (tagged-candidate (str \"::\" (name kw))))))\n\n(defn namespace-alias-candidates\n  \"Returns a list of namespace aliases prefixed by double colon required in the\n  given namespace.\"\n  [prefix ns]\n  (let [prefix (subs prefix 2)\n        ns-name (str ns)]\n    (for [[alias _] (ns-aliases ns)\n          :let [aname (name alias)]\n          :when (.startsWith aname prefix)]\n      (tagged-candidate (str \"::\" aname)))))\n\n(defn aliased-candidates\n  \"Returns a list of alias-qualified double-colon keywords (like ::str/foo),\n  where alias has to be registered in the given namespace.\"\n  [prefix ns]\n  (when-let [[_ alias prefix] (re-matches #\"::([^/]+)/(.*)\" prefix)]\n    (let [alias-ns-name (str (resolve-namespace (symbol alias) ns))]\n      (for [[kw _] (keywords-table)\n            :when (= (namespace kw) alias-ns-name)\n            :when (.startsWith (name kw) prefix)]\n        (tagged-candidate (str \"::\" alias \"/\" (name kw)))))))\n\n(defn candidates\n  [^String prefix, ns _]\n  (let [single-colon? (.startsWith prefix \":\")\n        double-colon? (.startsWith prefix \"::\")\n        has-slash? (> (.indexOf prefix \"/\") -1)]\n    (cond (and double-colon? has-slash?) (aliased-candidates prefix ns)\n          double-colon? (concat (qualified-candidates prefix ns)\n                                (namespace-alias-candidates prefix ns))\n          single-colon? (for [[kw _] (keywords-table)\n                              :when (.startsWith (str kw) (subs prefix 1))]\n                          (tagged-candidate (str \":\" kw))))))\n\n(defsource ::keywords\n  :candidates #'candidates\n  :doc (constantly nil))\n(ns compliment.sources.resources\n  \"Completion for bundled resource files.\"\n  (:require [clojure.java.io :as io]\n            [compliment.sources :refer [defsource]]\n            [compliment.utils :as utils])\n  (:import java.io.File\n           java.net.URLConnection))\n\n(defn inside-resource-call?\n  \"If context is not nil, check if prefix inside the string in a\n  clojure.java.io/resource call.\"\n  [ctx]\n  (when (and ctx)\n    (let [[str call] ctx\n          fn (first (:form call))]\n      (and (string? (:form str))\n           (list? (:form call))\n           (symbol? fn)\n           (= (name fn) \"resource\")))))\n\n(defn candidates\n  \"Returns list of completions for project resources if within certain context.\"\n  [prefix _ context]\n  (when (inside-resource-call? context)\n    (for [^String res (utils/project-resources)\n          :when (.startsWith res prefix)]\n      {:candidate res\n       :type :resource})))\n\n(defn doc\n  \"Documentation function for project resources.\"\n  [resource-name _]\n  (try (let [^String filename (.getFile (io/resource resource-name))]\n         (format \"File type: %s, size: %d bytes\"\n                 (or (URLConnection/guessContentTypeFromName filename)\n                     \"application/unknown\")\n                 (.length (io/file filename))))\n       (catch Exception ex nil)))\n\n(defsource ::resources\n  :candidates #'candidates\n  :doc #'doc)\n(ns compliment.sources.ns-mappings\n  \"Completion for vars and classes in the current namespace.\"\n  (:require [compliment.sources :refer [defsource]]\n            [compliment.utils :refer [fuzzy-matches? resolve-namespace\n                                      *extra-metadata*]])\n  (:import java.io.StringWriter))\n\n(defn var-symbol?\n  \"Test if prefix resembles a var name.\"\n  [x]\n  (re-matches #\"([^\\/\\:][^\\.\\/]*([^\\/\\:]*\\/[^\\.\\/]*)?)?\" x))\n\n(defn dash-matches?\n  \"Tests if prefix partially matches a var name with dashes as\n  separators.\"\n  [prefix var]\n  (fuzzy-matches? prefix var \\-))\n\n(defn get-scope-and-prefix\n  \"Tries to get take apart scope namespace and prefix in prefixes like\n  `scope/var`.\"\n  [^String s, ns]\n  (let [[scope-name sym] (if (> (.indexOf s \"/\") -1)\n                           (.split s \"/\") ())\n        scope (when scope-name\n                (resolve-namespace (symbol scope-name) ns))\n        prefix (if scope\n                 (or sym \"\") s)]\n    [scope-name scope prefix]))\n\n(defn try-get-ns-from-context\n  \"Tries to extract a namespace name if context is a `ns` definition.\"\n  [context]\n  (let [[var-list ns-def use-def top-form] context]\n    (when (and (sequential? (:form var-list))\n               (= (first (:form top-form)) 'ns)\n               (or (and (= (first (:form use-def)) :use)\n                        (= (second (:form ns-def)) :only))\n                   (and (= (first (:form use-def)) :require)\n                        (= (second (:form ns-def)) :refer))))\n      (find-ns (first (:form ns-def))))))\n\n(defn generate-docstring\n  \"Generates a docstring from a given var metadata. Copied from\n  `clojure.repl` with some minor modifications.\"\n  [m]\n  (binding [*out* (StringWriter.)]\n    (println (str (when-let [ns (:ns m)] (str (ns-name ns) \"/\")) (:name m)))\n    (cond\n      (:forms m) (doseq [f (:forms m)]\n                   (print \"  \")\n                   (prn f))\n      (:arglists m) (prn (:arglists m)))\n    (if (:special-form m)\n      (do\n        (println \"Special Form\")\n        (println \" \" (:doc m))\n        (if (contains? m :url)\n          (when (:url m)\n            (println (str \"\\n  Please see http://clojure.org/\" (:url m))))\n          (println (str \"\\n  Please see http://clojure.org/special_forms#\"\n                        (:name m)))))\n      (do\n        (when (:macro m)\n          (println \"Macro\"))\n        (println \" \" (:doc m))))\n    (str *out*)))\n\n(defn candidates\n  \"Returns a list of namespace-bound candidates, with namespace being\n  either the scope (if prefix is scoped), `ns` arg or the namespace\n  extracted from context if inside `ns` declaration.\"\n  [^String prefix, ns context]\n  (when (var-symbol? prefix)\n    (let [[scope-name scope ^String prefix] (get-scope-and-prefix prefix ns)\n          ns-form-namespace (try-get-ns-from-context context)\n          vars (cond\n                 scope (ns-publics scope)\n                 ns-form-namespace (ns-publics ns-form-namespace)\n                 :else (ns-map ns))]\n      (for [[var-sym var] vars\n            :let [var-name (name var-sym)\n                  {:keys [arglists doc] :as var-meta} (meta var)]\n            :when (dash-matches? prefix var-name)]\n        (if (= (type var) Class)\n          {:candidate var-name, :type :class,\n           :package (when-let [pkg (.getPackage ^Class var)]\n                      ;; Some classes don't have a package\n                      (.getName ^Package pkg))}\n\n          (cond-> {:candidate (if scope\n                                (str scope-name \"/\" var-name)\n                                var-name)\n                   :type (cond (:macro var-meta) :macro\n                               arglists :function\n                               :else :var)\n                   :ns (str (or (:ns var-meta) ns))}\n            (and arglists(:arglists *extra-metadata*))\n            (assoc :arglists (apply list (map pr-str arglists)))\n\n            (and doc (:doc *extra-metadata*))\n            (assoc :doc (generate-docstring var-meta))))))))\n\n(defn doc\n  \"Documentation function for this sources' completions.\"\n  [symbol-str ns]\n  (if (var-symbol? symbol-str)\n    (when-let [var (ns-resolve ns (symbol symbol-str))]\n      (when (meta var)\n        (generate-docstring (meta var))))))\n\n(defsource ::ns-mappings\n  :candidates #'candidates\n  :doc #'doc)\n(ns compliment.sources.special-forms\n  \"Completion for Clojure's special forms.\"\n  (:require [clojure.repl :as repl]\n            [compliment.sources :refer [defsource]]\n            [compliment.sources.ns-mappings :as vars]))\n\n(def ^:private special-forms\n  (set (map name '[def if do quote var recur throw try catch\n                   monitor-enter monitor-exit new set!])))\n\n(defn first-item-in-list?\n  \"If context is not nil, check if prefix is the first item in a list form.\"\n  [ctx]\n  (if ctx\n    (when-let [expr (first ctx)]\n      (and (list? (:form expr)) (= (:idx expr) 0)))\n    true))\n\n(defn candidates\n  \"Returns list of completions for special forms.\"\n  [prefix _ context]\n  (when (and (vars/var-symbol? prefix) (first-item-in-list? context))\n    (for [form special-forms\n          :when (vars/dash-matches? prefix form)]\n      {:candidate form\n       :type :special-form})))\n\n(defn doc\n  \"Documentation function for special forms.\"\n  [symbol-str _]\n  (when (and (vars/var-symbol? symbol-str) (special-forms symbol-str))\n    (vars/generate-docstring (#'repl/special-doc (symbol symbol-str)))))\n\n(defsource ::special-forms\n  :candidates #'candidates\n  :doc #'doc)\n\n(defn literal-candidates\n  \"We define `true`, `false`, and `nil` in a separate source because they are\n  not context-dependent (don't have to be first items in the list).\"\n  [prefix _ __]\n  (->> [\"true\" \"false\" \"nil\"]\n       (filter #(.startsWith ^String % prefix))\n       (map (fn [c] {:candidate c, :type :special-form}))))\n\n(defsource ::literals\n  :candidates #'literal-candidates\n  :doc (constantly nil))\n(ns compliment.sources.local-bindings\n  \"Completion source for local bindings introduced by defn, let and the like.\"\n  (:require [compliment.sources :refer [defsource]]\n            [compliment.sources.ns-mappings :refer [var-symbol? dash-matches?]]))\n\n(def let-like-forms '#{let if-let when-let if-some when-some loop})\n\n(def defn-like-forms '#{defn defn- fn defmacro})\n\n(def doseq-like-forms '#{doseq for})\n\n(defn parse-binding\n  \"Given a binding node returns the list of local bindings introduced by that\n  node. Handles vector and map destructuring.\"\n  [binding-node]\n  (cond (vector? binding-node)\n        (mapcat parse-binding binding-node)\n\n        (map? binding-node)\n        (let [normal-binds (->> (keys binding-node)\n                                (remove keyword?)\n                                (mapcat parse-binding))\n              keys-binds (if-let [ks (:keys binding-node)]\n                           (mapv str ks) ())\n              as-binds (if-let [as (:as binding-node)]\n                        [(str as)] ())]\n          (concat normal-binds keys-binds as-binds))\n\n        (not (#{'& '_} binding-node))\n        [(str binding-node)]))\n\n(defn extract-local-bindings\n  \"When given a form that has a binding vector traverses that binding vector and\n  returns the list of all local bindings.\"\n  [form]\n  (when (list? form)\n    (cond (let-like-forms (first form))\n          (mapcat parse-binding (take-nth 2 (second form)))\n\n          (defn-like-forms (first form))\n          (mapcat parse-binding\n                  (loop [[c & r] (rest form), bnodes []]\n                    (cond (nil? c) bnodes\n                          (list? c) (recur r (conj bnodes (first c)))\n                          (vector? c) c\n                          :else (recur r bnodes))))\n\n          (doseq-like-forms (first form))\n          (->> (partition 2 (second form))\n               (mapcat (fn [[left right]]\n                         (if (= left :let)\n                           (take-nth 2 right) [left])))\n               (mapcat parse-binding)))))\n\n(defn bindings-from-context\n  \"Returns all local bindings that are established inside the given context.\"\n  [ctx]\n  (try (distinct (mapcat (comp extract-local-bindings :form) ctx))\n       (catch Exception ex ())))\n\n(defn candidates\n  \"Returns a list of local bindings inside the context that match prefix.\"\n  [prefix _ context]\n  (when (var-symbol? prefix)\n    (for [binding (bindings-from-context context)\n          :when (dash-matches? prefix binding)]\n      {:candidate binding, :type :local})))\n\n(defsource ::local-bindings\n  :candidates #'candidates\n  :doc (constantly nil))\n;; ## Compliment - a completion library you deserve.\n;; This library provides a fast and extensible way to complete symbols in your\n;; editor. It is intended to be maximally editor-agnostic where\n;; possible, to avoid duplicating implementation in different clients.\n\n(ns compliment.core\n  \"Core namespace. Most interactions with Compliment should happen\n  through functions defined here.\"\n  (:require (compliment.sources ns-mappings\n                                namespaces-and-classes\n                                class-members\n                                keywords\n                                special-forms\n                                local-bindings\n                                resources)\n            [compliment.sources :refer [all-sources]]\n            [compliment.context :refer [cache-context]]\n            [compliment.utils :refer [*extra-metadata*]]\n            [clojure.string :refer [join]])\n  (:import java.util.Comparator))\n\n(def all-files\n  \"List of all Compliment files in an order they should be loaded. This is\n  required by REPLy.\"\n  (map (partial format \"compliment/%s.clj\")\n       [\"utils\" \"context\" \"sources\" \"sources/class_members\"\n        \"sources/ns_mappings\" \"sources/namespaces_and_classes\"\n        \"sources/keywords\" \"sources/special_forms\" \"sources/local_bindings\"\n        \"sources/resources\"\n        \"core\"]))\n\n(def ^:private by-length-comparator\n  (reify Comparator\n    (compare [_ s1 s2]\n      (let [res (compare (count s1) (count s2))]\n        (if (zero? res)\n          (compare s1 s2)\n          res)))))\n\n(defn sort-by-length\n  \"Sorts list of strings by their length first, and then alphabetically if\n  length is equal. Works for tagged and non-tagged results.\"\n  [candidates]\n  (sort-by :candidate by-length-comparator candidates))\n\n(defn ensure-ns\n  \"Takes either a namespace object or a symbol and returns the corresponding\n  namespace if it exists, otherwise returns `user` namespace.\"\n  [ns]\n  (cond (instance? clojure.lang.Namespace ns) ns\n        (symbol? ns) (or (find-ns ns) (find-ns 'user) *ns*)\n        :else *ns*))\n\n(defn completions\n  \"Returns a list of completions for the given prefix. Options map can contain\n  the following options:\n  - :ns - namespace where completion is initiated;\n  - :context - code form around the prefix;\n  - :sort-order (either :by-length or :by-name);\n  - :plain-candidates - if true, returns plain strings instead of maps;\n  - :extra-metadata - set of extra fields to add to the maps;\n  - :sources - list of source keywords to use.\"\n  ([prefix]\n   (completions prefix {}))\n  ([prefix options-map]\n   (if (string? options-map)\n     (completions prefix {:context options-map})\n     (let [{:keys [ns context sort-order sources extra-metadata]\n            :or {sort-order :by-length}} options-map\n           ns (ensure-ns ns)\n           options-map (assoc options-map :ns ns)\n           ctx (cache-context context)\n           sort-fn (if (= sort-order :by-name)\n                     (partial sort-by :candidate)\n                     (partial sort-by-length true))]\n       (binding [*extra-metadata* extra-metadata]\n         (let [candidate-fns (keep (fn [[_ src]]\n                                     (when (:enabled src)\n                                       (:candidates src)))\n                                   (if sources\n                                     (all-sources sources)\n                                     (all-sources)))]\n           (as-> (mapcat (fn [f] (f prefix ns ctx)) candidate-fns)\n               candidates\n\n             (if (= sort-order :by-name)\n               (sort-by :candidate candidates)\n               (sort-by :candidate by-length-comparator candidates))\n\n             (if (:plain-candidates options-map)\n               (map :candidate candidates)\n               candidates)\n\n             (doall candidates))))))))\n\n(defn documentation\n  \"Returns a documentation string that describes the given symbol.\"\n  ([symbol-str]\n   (documentation symbol-str *ns*))\n  ([symbol-str ns]\n   (if (empty? symbol-str)\n     \"\"\n     (->> (for [[_ {:keys [doc enabled]}] (all-sources)\n                :when enabled\n                :let [docstr (doc symbol-str (ensure-ns ns))]\n                :when docstr]\n            docstr)\n          (interpose \"\\n\\n\")\n          join))))\n" java.io.StringReader. clojure.lang.LineNumberingPushbackReader.)] (try (clojure.core/binding [clojure.core/*ns* clojure.core/*ns*] (clojure.core/loop [ret__1839__auto__ nil] (clojure.core/let [form__1840__auto__ (clojure.core/read rdr__1838__auto__ false (quote eof__1841__auto__))] (if (clojure.core/= (quote eof__1841__auto__) form__1840__auto__) ret__1839__auto__ (recur (clojure.core/eval form__1840__auto__)))))) (catch java.lang.Throwable t__1842__auto__ (clojure.core/println "[:unrepl.upgrade/failed]") (throw t__1842__auto__))))
